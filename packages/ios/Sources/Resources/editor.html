<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NoteCove Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            background: #fff;
            padding: 16px;
        }

        .ProseMirror {
            outline: none;
            min-height: 200px;
        }

        .ProseMirror h1 {
            font-size: 2em;
            margin: 0.67em 0;
            font-weight: bold;
        }

        .ProseMirror h2 {
            font-size: 1.5em;
            margin: 0.75em 0;
            font-weight: bold;
        }

        .ProseMirror h3 {
            font-size: 1.17em;
            margin: 0.83em 0;
            font-weight: bold;
        }

        .ProseMirror p {
            margin: 0.5em 0;
        }

        .ProseMirror ul,
        .ProseMirror ol {
            padding-left: 1.5em;
            margin: 0.5em 0;
        }

        .ProseMirror li {
            margin: 0.25em 0;
        }

        .ProseMirror strong {
            font-weight: bold;
        }

        .ProseMirror em {
            font-style: italic;
        }

        .ProseMirror code {
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .ProseMirror pre {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .ProseMirror blockquote {
            border-left: 3px solid #ddd;
            padding-left: 1em;
            margin: 0.5em 0;
            color: #666;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background: #1c1c1e;
                color: #ffffff;
            }

            .ProseMirror blockquote {
                border-left-color: #444;
                color: #aaa;
            }

            .ProseMirror code,
            .ProseMirror pre {
                background: #2c2c2e;
            }
        }
    </style>
</head>
<body>
    <div id="editor"></div>

    <!-- Load TipTap from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/y-prosemirror@1.2.1/dist/y-prosemirror.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/yjs@13.6.7/dist/yjs.js"></script>
    <script type="module">
        import { Editor } from 'https://cdn.jsdelivr.net/npm/@tiptap/core@2.1.13/+esm';
        import StarterKit from 'https://cdn.jsdelivr.net/npm/@tiptap/starter-kit@2.1.13/+esm';
        import Collaboration from 'https://cdn.jsdelivr.net/npm/@tiptap/extension-collaboration@2.1.13/+esm';
        import Underline from 'https://cdn.jsdelivr.net/npm/@tiptap/extension-underline@2.1.13/+esm';

        // Create Yjs document
        const ydoc = new Y.Doc();
        let editor = null;
        let noteId = null;

        // Initialize editor
        function initEditor() {
            editor = new Editor({
                element: document.getElementById('editor'),
                extensions: [
                    StarterKit.configure({
                        history: false, // Yjs handles history
                    }),
                    Underline,
                    Collaboration.configure({
                        document: ydoc,
                        fragment: ydoc.getXmlFragment('content'),
                    }),
                ],
                editable: true,
                onUpdate: ({ editor }) => {
                    // Send update to Swift when content changes
                    sendMessage('contentChanged', {
                        noteId: noteId,
                        text: editor.getText(),
                        isEmpty: editor.isEmpty,
                    });
                },
            });

            sendMessage('editorReady', {});
        }

        // Send message to Swift
        function sendMessage(type, data) {
            try {
                window.webkit.messageHandlers.editor.postMessage({
                    type: type,
                    data: data,
                });
            } catch (error) {
                console.error('Failed to send message to Swift:', error);
            }
        }

        // Handle messages from Swift
        window.loadNote = function(id, stateBase64) {
            try {
                noteId = id;

                if (stateBase64 && stateBase64.length > 0) {
                    // Decode base64 to Uint8Array
                    const binaryString = atob(stateBase64);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    // Apply state to Yjs document
                    Y.applyUpdate(ydoc, bytes);
                }

                sendMessage('noteLoaded', { noteId: id });
            } catch (error) {
                sendMessage('error', { message: error.toString() });
            }
        };

        window.applyUpdate = function(updateBase64) {
            try {
                // Decode base64 to Uint8Array
                const binaryString = atob(updateBase64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Apply update to Yjs document
                Y.applyUpdate(ydoc, bytes);
            } catch (error) {
                sendMessage('error', { message: error.toString() });
            }
        };

        window.executeCommand = function(command, params) {
            try {
                if (!editor) return;

                switch (command) {
                    case 'toggleBold':
                        editor.chain().focus().toggleBold().run();
                        break;
                    case 'toggleItalic':
                        editor.chain().focus().toggleItalic().run();
                        break;
                    case 'toggleUnderline':
                        editor.chain().focus().toggleUnderline().run();
                        break;
                    case 'toggleHeading':
                        editor.chain().focus().toggleHeading({ level: params.level || 1 }).run();
                        break;
                    case 'toggleBulletList':
                        editor.chain().focus().toggleBulletList().run();
                        break;
                    case 'toggleOrderedList':
                        editor.chain().focus().toggleOrderedList().run();
                        break;
                    case 'toggleBlockquote':
                        editor.chain().focus().toggleBlockquote().run();
                        break;
                    case 'undo':
                        editor.chain().focus().undo().run();
                        break;
                    case 'redo':
                        editor.chain().focus().redo().run();
                        break;
                }
            } catch (error) {
                sendMessage('error', { message: error.toString() });
            }
        };

        window.getDocumentState = function() {
            try {
                const state = Y.encodeStateAsUpdate(ydoc);
                // Convert Uint8Array to base64
                let binary = '';
                const len = state.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(state[i]);
                }
                const base64 = btoa(binary);

                sendMessage('documentState', { state: base64 });
            } catch (error) {
                sendMessage('error', { message: error.toString() });
            }
        };

        // Listen for Yjs updates to send to Swift
        ydoc.on('update', (update, origin) => {
            // Don't send updates that came from Swift
            if (origin === 'swift') return;

            // Convert Uint8Array to base64
            let binary = '';
            const len = update.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(update[i]);
            }
            const base64 = btoa(binary);

            sendMessage('update', { update: base64 });
        });

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEditor);
        } else {
            initEditor();
        }
    </script>
</body>
</html>
